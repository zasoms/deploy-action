!function(require, directRequire){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.uploadByCos=void 0;const tslib_1=require("tslib"),url_config_1=require("../utils/url_config"),tools_1=require("../utils/tools"),request_1=require("../utils/request"),sign_1=require("../utils/sign"),pack_1=require("./utils/pack"),zlib=require("zlib"),crypto=require("crypto"),config_1=require("../config"),upload_1=require("./upload"),log_1=(0,tslib_1.__importDefault)(require("../utils/log")),jsonParse_1=require("../utils/jsonParse"),COS=require("cos-nodejs-sdk-v5");async function putBufferToCos(e,t){const r=new COS({Proxy:(0,request_1.getCiProxy)(),getAuthorization(e,r){r({TmpSecretId:t.secret_id,TmpSecretKey:t.secret_key,XCosSecurityToken:t.token,ExpiredTime:t.expired_time})}});try{return await new Promise((o,i)=>{r.putObject({Bucket:t.bucket,Region:"ap-shanghai",Key:t.object,Body:e,onProgress(e){}},(e,t)=>{if(e)return console.error(e),i(e.error);o(t)})})}catch(e){throw new Error("upload to cos failed: "+e.message)}}async function innerRequest(e,t){const r=await(0,request_1.request)({url:e,method:"post",body:t,headers:{"content-type":"application/json"}});let o;try{o=JSON.parse(r.body)}catch(t){const r=`request ${e} failed: resp body is not a valid json`;throw log_1.default.error(r),new Error(r)}if(0!==o.errCode)throw new Error(`request failed, errCode: ${o.errCode}, errMsg: ${o.errMsg}`);return o.data}async function uploadByCos(e,t,r,o){let i;try{const e=await(0,sign_1.getSignature)(r.privateKey,r.appid);i=await innerRequest(url_config_1.GET_UPLOAD_TOKEN,JSON.stringify({appid:r.appid,signature:e,robot:o}))}catch(e){return console.error("uploadToken error",e),{fallback:!0}}const s=e,a=crypto.randomBytes(12),n=crypto.createCipheriv("aes-256-gcm",Buffer.from(i.crypt_key,"base64"),a),u=Buffer.concat([n.update(s),n.final()]),c=n.getAuthTag(),l=Buffer.alloc(1);l.writeUInt8(c.length+a.length,0);const p=Buffer.concat([l,c,a,u]),d=Date.now();await putBufferToCos(p,i);const _=Date.now()-d,f=(0,tools_1.generateMD5)(s),g=await(0,sign_1.getSignature)(r.privateKey,r.appid),y=`${t}&task_id=${i.task_id}&new_hash=${f}&upload_cos_cost_time=${_}`;log_1.default.info("request url:",y);let w=await(0,request_1.request)({url:y,method:"post",body:zlib.gzipSync((0,pack_1.pack)({[upload_1.SIGNATURE_FILE_NAME]:JSON.stringify({signature:g,version:config_1.CI_VERSION})}).buffer)});if(0!==(0,jsonParse_1.jsonRespParse)(w.body.toString(),t).errCode)throw new Error(w.body.toString());for(;;){const e=await(0,sign_1.getSignature)(r.privateKey,r.appid),t=await innerRequest(`${url_config_1.GET_ASYNC_RESULT}?task_id=${i.task_id}`,JSON.stringify({appid:r.appid,signature:e,robot:o}));if(1!==t.status){if(0===t.status)return{fallback:!1,body:t,uploadCOSCostTime:_};if(3===t.status)throw new Error(`upload failed with status ${t.status}, task not found`);throw new Error("upload failed with status "+t.status)}await new Promise(e=>{setTimeout(e,1e3)})}}exports.uploadByCos=uploadByCos;
}(require("licia/lazyImport")(require), require)